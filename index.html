<!doctype html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport"
          content="width=device-width, user-scalable=no, initial-scale=1.0, maximum-scale=1.0, minimum-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>Document</title>
</head>
<body>
<div>
    <div id="progress"></div>
    <button id="menu">Меню (нажми меня)</button>
</div>
<script>
"use strict";
globalThis.__codeBoxId = "2vmafvyc0y";

/**
 * 1) выполнить самую древнею макрозадачу
 * 2) выполнить всю очередь микрозадач
 * 3) отрисовать изменения на экране
 * 4) ничего не делать до прихода следующей макрозадачи
 * 5) переидти к шагу 1
 */

/**
 * макрозадачи: это те задачи, что попадают в очередь - колбек setTimeout,
 * создание события mouseEvent, и выполнение  обработчика события mouseEvent,
 * выполнение скрипта в виде какого-нибудь цикла, и т.д
 *
 * Микрозадачи: это промисы, async await.
 */

// 1) большая макрозадача не дает отрисовывать изменения в ui,
// поэтому мы ее разбиваем.

// 1.1) неразбитый неоптимизированный код: отрисовку
// числа счетчика мы увидим только в конце. Мы не будем наблюдать как он меняется

// function count() {
//     for (let i = 0; i< 1e7; i++) {
//         i++;
//         progress.innerHTML = i;
//     }
// }
// count();
// 1.2) разбитый оптимизированный код: отрисовку
// числа счетчика мы увидим между циклами do while. Мы будем наблюдать как он меняется

// let i = 0;
// let start = Date.now();
// function count() {
//
//     // сделать часть крупной задачи
//     do {
//         i++;
//         progress.innerHTML = i;
//     } while (i % 1e3 !== 0);
//
//     if (i < 1e7) {
//         setTimeout(count);
//     }
// if (i === 1e7) {
//     // выведет Done in 71022ms
//     alert("Done in " + (Date.now() - start) + 'ms');
// }
// }
// count();
// 1.3) разбиваем макротаску на несколько макротасок +
// планируем вызов следующей макротаски сразу в начале выполнения текущей макротаски,
// а не в конце как в предыдущем примере.
// это дает эффект: в предыдущем примере из-за планирования в конце setTimeout опаздывал на 4 мс
// а теперь он сраюатывает сразу при 0 мс.
// Чем раньше заранее будут определены макротаски тем меньше суммарное время выполнения их.

// let i = 0;
// let start = Date.now();
// function count() {
//
//     if (i < 1e7) {
//         setTimeout(count);
//     }
//     // сделать часть крупной задачи
//     do {
//         i++;
//         progress.innerHTML = i;
//     } while (i % 1e3 !== 0);
// if (i == 1e7) {
//     // выведет Done in 45271ms
//     alert("Done in " + (Date.now() - start) + 'ms');
// }
// }
// count();
//
// 2.1) Обработка событий диспатчащихся (отправляющихся) внутри обработчика другого события
/**
 * Суть: если браузер выполняет обработчик события onclick и тут во время этого выполнения
 * произошла отправка другого события, то обработчик другого события не начинает свое выполнение
 * до тех пор пока не завершится onclick.
 *
 * Исключение: если браузер выполняет обработчик события onclick и тут во время этого выполнения
 * произошла отправка другого события внутри этого самого обработчика onclick, тогда браузер прервет выполнение onclick,
 * начнет выполнять обработчик другого события и лишь выполнив его, вновь вернется к выполнению onclick.
 *
 */
// menu.onclick = function() {
//     alert(1);
//
//     // alert("вложенное событие")
//     menu.dispatchEvent(new CustomEvent("menu-open", {
//         bubbles: true
//     }));
//
//     alert(2);
// };
//
// document.addEventListener('menu-open', () => alert('вложенное событие'))

// Порядок вывода: 1 → вложенное событие → 2.

// 2.2) Как отложить обработку событий диспатчащихся (отправляющихся) внутри обработчика другого события?

// menu.onclick = function() {
//     alert(1);
//
//     // alert(2)
//     setTimeout(() => menu.dispatchEvent(new CustomEvent("menu-open", {
//         bubbles: true
//     })));
//
//     alert(2);
// };
//
// document.addEventListener('menu-open', () => alert('вложенное событие'));

// колбек setTimeout это макротаска и она выполнится после выполнения синхронного кода алертов

// 3) микротаски выполняются раньше макротасок, а синхронный код раньше микротасок.
// setTimeout(() => alert("timeout"));
// Promise.resolve()
//     .then(() => alert("promise"));
// alert('код выполнен');

// 4) сделать действие микротаской можно с помощью queueMicrotask
// let i = 0;
//
// function count() {
//
//     // делаем часть крупной задачи (*)
//     do {
//         i++;
//         progress.innerHTML = i;
//     } while (i % 1e3 !== 0);
//
//     if (i < 1e6) {
//         queueMicrotask(count);
//     }
//
// }
//
// count();
</script>
</body>
</html>